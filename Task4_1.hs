module Task4_1 where

{-
  Задание 4.1
  Реализация монады над функцией.
  Реализуйте все требуемые классы типов и объясните, почему они реализованы именно так.
-}

-- Монада над функцией. В качестве входного значения `fun` может быть что угодно
-- Собственно, почему бы не `String`?
data FunMonad a = FunMonad { fun :: String -> a }

-- реализуйте классы `Functor`, `Applicative` и `Monad` для типа `FunMonad`

instance Functor FunMonad where
    fmap f (FunMonad fun) = FunMonad $ f.fun
    
-- По определению fmap::(a -> b) -> f a -> f b т.е. применение функции к значению в контексте 
-- FunMonad fun - запакованное значение String -> a
-- f - непосредственно функция a -> b
-- На выходе получаем применени f к fun, а именно String -> b, и все это является FunMonad
-- Все сходится

instance Applicative FunMonad where
    pure a = FunMonad (\x -> a)
    (<*>) (FunMonad fun) (FunMonad arg) = FunMonad (\x -> fun x $ arg x)
    
-- Чтобы реализовать клас типов Апликативный функтор надо определить две функции - pure и <*>
-- pure это помещение чего либо в контекст
-- Соответственно реализациф выглядит как взятие чего либо произвольного типа а
-- и получение из этого чего-либо FunMonad
-- Для краткости записи используем лямбду

-- Функция <*> как раз является основной используемой в Апликативе
-- Ее суть - применение функции в контексте к значнию в контексте
-- Результат тоже должен быть в контексте, поэтому он и выглядит как экземпляр FunMona
-- сама же суть происходящего это : достать из контекста аргумент, достать из контекста 
-- функцию, применить функцию к элементу и запаковать обратно в контекст
-- это и делаем, опять используя лямбду

instance Monad FunMonad where
    (>>=) (FunMonad fa) f = FunMonad (\x -> fun (f (fa x)) x)
    
-- По определению (>>=) :: m a -> (a -> m b) -> m b
-- Суть процесса - применить к значению в контексте функцию
-- которая возвращает значение в контексте 
-- Механизм работы немного отличается. Если в апликативе мы разворачивали и то и то, 
-- а затем применяли, тот тут разворачиваем только аргумент, затем применяем к функции, которую не
-- надо разворачивать, потому что она не обернута, она сама по себе возвращает значение в контексте
-- Собственно это мы и делаем с помощью лямбды
